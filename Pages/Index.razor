@page "/"

<h1>Welcome to my website!</h1>
<h2>I'm James.</h2>

<BECanvas Width="300" Height="400" @ref="_canvasReference" ></BECanvas>

@code {
    private WebGLContext _webGLContext;

    protected BECanvasComponent _canvasReference;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        //Vertex shader GLSL source code
        string vertCode = "attribute vec3 coordinates;"
                            + "void main(void) {gl_Position = vec4(coordinates, 1.0);}";
        
        //Fragment shader GLSL source code
        string fragCode = "void main(void) {gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);}";
        
        //Create the WebGL context
        this._webGLContext = await this._canvasReference.CreateWebGLAsync();

        float[] vertices = {-0.5f,0.5f,0.0f, -0.5f,-0.5f,0.0f, 0.5f,-0.5f,0.0f, 0.5f,0.5f,0.0f};

        UInt16[] indexes = {0,1,2, 0,2,3};

        
        var shaderProgram = await InitShaderProgram(this._webGLContext, vertCode, fragCode);

        var vertexBuffer = await InitArrayBuffer(this._webGLContext, vertices);
        var indexBuffer = await InitElementArrayBuffer(this._webGLContext, indexes);

        await AssociateShadersToBuffers(this._webGLContext, vertexBuffer, indexBuffer, shaderProgram, "coordinates");        

        await DrawScene(this._webGLContext, shaderProgram, indexes.Length);
    }

    private async Task DrawScene(WebGLContext webGLContext, WebGLProgram shaderProgram, int numIndexes){
        //Tell WebGL which shader program to use
        await webGLContext.UseProgramAsync(shaderProgram);

        //Clear the canvas
        await webGLContext.ClearColorAsync(0, 0, 0, 1);

        //Enable the depth test
        await webGLContext.EnableAsync(EnableCap.DEPTH_TEST);

        //Clear the colour buffer bit
        await webGLContext.ClearAsync(BufferBits.COLOR_BUFFER_BIT);

        //Set the viewport
        await webGLContext.ViewportAsync(0, 0, (int)_canvasReference.Width, (int)_canvasReference.Height);

        //Draw the triangle
        await webGLContext.DrawElementsAsync(Primitive.TRIANGLES, numIndexes, DataType.UNSIGNED_SHORT, 0);
    }

    private async Task<WebGLProgram> InitShaderProgram(WebGLContext webGLContext, string vertCode, string fragCode){
        //Load the shaders
        var vertShader = await LoadShader(webGLContext, ShaderType.VERTEX_SHADER, vertCode);
        var fragShader = await LoadShader(webGLContext, ShaderType.FRAGMENT_SHADER, fragCode);

        //Create the shader program
        var shaderProgram = await webGLContext.CreateProgramAsync();
        await webGLContext.AttachShaderAsync(shaderProgram, vertShader);
        await webGLContext.AttachShaderAsync(shaderProgram, fragShader);
        await webGLContext.LinkProgramAsync(shaderProgram);

        //Check if creating the shader program failed
        if(!await webGLContext.GetProgramParameterAsync<bool>(shaderProgram, ProgramParameter.LINK_STATUS)){
            throw new Exception("Unable to initialize the shader program: " + await webGLContext.GetProgramInfoLogAsync(shaderProgram));    
        }

        return shaderProgram;
    }

    private async Task<WebGLShader> LoadShader(WebGLContext webGLContext, ShaderType type, string source){
        //Create a shader
        var shader = await webGLContext.CreateShaderAsync(type);

        //Load the source code to the shader
        await webGLContext.ShaderSourceAsync(shader, source);

        //Compile the shader
        await webGLContext.CompileShaderAsync(shader);

        //Check that the shader compiled successfully
        if(!await webGLContext.GetShaderParameterAsync<bool>(shader, ShaderParameter.COMPILE_STATUS)){
            throw new Exception("An error occurred when compiling the shaders: " + await webGLContext.GetShaderInfoLogAsync(shader));    
        }

        return shader;
    }

    private async Task<WebGLBuffer> InitArrayBuffer(WebGLContext webGLContext, float[] vectors){
        //Create a buffer for the vectors and bind an empty array to it
        var buffer = await webGLContext.CreateBufferAsync();
        await webGLContext.BindBufferAsync(BufferType.ARRAY_BUFFER, buffer);

        //Send the vectors to WebGL
        await webGLContext.BufferDataAsync(BufferType.ARRAY_BUFFER, vectors, BufferUsageHint.STATIC_DRAW);

        //Unbind the array from the buffer
        await webGLContext.BindBufferAsync(BufferType.ARRAY_BUFFER, null);

        return buffer;
    }

    private async Task<WebGLBuffer> InitElementArrayBuffer(WebGLContext webGLContext, UInt16[] elements){
        //Create a buffer for the elements and bind an empty array to it
        var buffer = await webGLContext.CreateBufferAsync();
        await webGLContext.BindBufferAsync(BufferType.ELEMENT_ARRAY_BUFFER, buffer);

        //Send the elements to WebGL
        await webGLContext.BufferDataAsync(BufferType.ELEMENT_ARRAY_BUFFER, elements, BufferUsageHint.STATIC_DRAW);

        //Unbind the array from the buffer
        await webGLContext.BindBufferAsync(BufferType.ELEMENT_ARRAY_BUFFER, null);

        return buffer;
    }

    private async Task AssociateShadersToBuffers(WebGLContext webGLContext, WebGLBuffer vertexBuffer, WebGLBuffer indexBuffer, WebGLProgram shaderProgram, string attribName){
        //Bind the buffer objects
        await webGLContext.BindBufferAsync(BufferType.ARRAY_BUFFER, vertexBuffer);
        await webGLContext.BindBufferAsync(BufferType.ELEMENT_ARRAY_BUFFER, indexBuffer);

        //Get the attribute location
        var attribLoc = (uint)await webGLContext.GetAttribLocationAsync(shaderProgram, attribName);

        //Point an attribute to the currently bound vertex buffer object
        await webGLContext.VertexAttribPointerAsync(attribLoc, 3, DataType.FLOAT, false, 0, 0);

        //Enable the attribute
        await webGLContext.EnableVertexAttribArrayAsync(attribLoc);
    }
}