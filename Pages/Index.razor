@page "/"

<h1>Welcome to my website!</h1>
<h2>I'm James.</h2>

<BECanvas Width="300" Height="400" @ref="_canvasReference" ></BECanvas>

@code {
    private WebGLContext _webGLContext;

    protected BECanvasComponent _canvasReference;

    //Vertex shader GLSL source code
    private const string vsSource = "attribute vec4 aVertexPosition; uniform mat4 uModelViewMatrix; uniform mat4 uProjectionMatrix; void main() {gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;}";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        //Vertex shader GLSL source code
        string vertCode = "attribute vec2 coordinates;"
                            + "void main(void) {gl_Position = vec4(coordinates, 0.0, 1.0);}";
        
        //Fragment shader GLSL source code
        string fragCode = "void main(void) {gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);}";

        this._webGLContext = await this._canvasReference.CreateWebGLAsync();

        float[] vertices = {-0.5f, 0.5f, -0.5f, -0.5f, 0.0f, -0.5f};

        
        var shaderProgram = await InitShaderProgram(this._webGLContext, vertCode, fragCode);

        var vertexBuffer = await InitBuffers(this._webGLContext, vertices);

        await ReadVertexBuffer(this._webGLContext, vertexBuffer, shaderProgram, "coordinates");        

        await drawScene(this._webGLContext, shaderProgram);
    }

    private async Task drawScene(WebGLContext webGLContext, WebGLProgram shaderProgram){
        //Tell WebGL which shader program to use
        await webGLContext.UseProgramAsync(shaderProgram);

        //Clear the canvas
        await webGLContext.ClearColorAsync(0, 0, 0, 1);

        //Enable the depth test
        await webGLContext.EnableAsync(EnableCap.DEPTH_TEST);

        //Clear the colour buffer bit
        await webGLContext.ClearAsync(BufferBits.COLOR_BUFFER_BIT);

        //Set the viewport
        await webGLContext.ViewportAsync(0, 0, (int)_canvasReference.Width, (int)_canvasReference.Height);

        //Draw the triangle
        await webGLContext.DrawArraysAsync(Primitive.TRIANGLES, 0, 3);
    }

    private async Task<WebGLProgram> InitShaderProgram(WebGLContext webGLContext, string vertCode, string fragCode){
        //Load the shaders
        var vertShader = await LoadShader(webGLContext, ShaderType.VERTEX_SHADER, vertCode);
        var fragShader = await LoadShader(webGLContext, ShaderType.FRAGMENT_SHADER, fragCode);

        //Create the shader program
        var shaderProgram = await webGLContext.CreateProgramAsync();
        await webGLContext.AttachShaderAsync(shaderProgram, vertShader);
        await webGLContext.AttachShaderAsync(shaderProgram, fragShader);
        await webGLContext.LinkProgramAsync(shaderProgram);

        //Check if creating the shader program failed
        if(!await webGLContext.GetProgramParameterAsync<bool>(shaderProgram, ProgramParameter.LINK_STATUS)){
            throw new Exception("Unable to initialize the shader program: " + await webGLContext.GetProgramInfoLogAsync(shaderProgram));    
        }

        return shaderProgram;
    }

    private async Task<WebGLShader> LoadShader(WebGLContext webGLContext, ShaderType type, string source){
        //Create a shader
        var shader = await webGLContext.CreateShaderAsync(type);

        //Load the source code to the shader
        await webGLContext.ShaderSourceAsync(shader, source);

        //Compile the shader
        await webGLContext.CompileShaderAsync(shader);

        //Check that the shader compiled successfully
        if(!await webGLContext.GetShaderParameterAsync<bool>(shader, ShaderParameter.COMPILE_STATUS)){
            throw new Exception("An error occurred when compiling the shaders: " + await webGLContext.GetShaderInfoLogAsync(shader));    
        }

        return shader;
    }

    private async Task<WebGLBuffer> InitBuffers(WebGLContext webGLContext, float[] vertices){
        //Create a buffer for the vertices and bind an empty array to it
        var vertexBuffer = await webGLContext.CreateBufferAsync();
        await webGLContext.BindBufferAsync(BufferType.ARRAY_BUFFER, vertexBuffer);

        //Send the vertices to WebGL to build a shape
        await webGLContext.BufferDataAsync(BufferType.ARRAY_BUFFER, vertices, BufferUsageHint.STATIC_DRAW);

        //Unbind the array from the buffer
        await webGLContext.BindBufferAsync(BufferType.ARRAY_BUFFER, null);

        return vertexBuffer;
    }

    private async Task ReadVertexBuffer(WebGLContext webGLContext, WebGLBuffer vertexBuffer, WebGLProgram shaderProgram, string attribName){
        //Bind the vertex buffer object
        await webGLContext.BindBufferAsync(BufferType.ARRAY_BUFFER, vertexBuffer);

        //Get the attribute location
        var attribLoc = (uint)await webGLContext.GetAttribLocationAsync(shaderProgram, attribName);

        //Point an attribute to the currently bound vertex buffer object
        await webGLContext.VertexAttribPointerAsync(attribLoc, 2, DataType.FLOAT, false, 0, 0);

        //Enable the attribute
        await webGLContext.EnableVertexAttribArrayAsync(attribLoc);
    }
}